# Saga Pattern

## 개념

분산 시스템에서 **여러 서비스에 걸친 트랜잭션**을 관리하는 패턴.

기존 모놀리식에서는 하나의 DB에서 `BEGIN → COMMIT/ROLLBACK`으로 원자성을 보장했지만, 마이크로서비스에서는 각 서비스가 별도 DB를 가지므로 이 방식이 불가능하다.

```
모놀리식: 하나의 트랜잭션으로 처리
  주문 생성 → 재고 차감 → 결제 처리 (한 DB에서 COMMIT or ROLLBACK)

마이크로서비스: 각각 별도 DB
  주문 서비스(DB1) → 재고 서비스(DB2) → 결제 서비스(DB3)
  → 결제 실패하면? 이미 커밋된 주문/재고는 어떻게?
```

## 핵심 아이디어

```
Saga = 로컬 트랜잭션 시퀀스 + 보상 트랜잭션

정상: T1 → T2 → T3 → 완료
실패: T1 → T2 → T3(실패) → C2 → C1 (보상으로 롤백)
```

각 단계마다:

- **로컬 트랜잭션 (T)**: 해당 서비스의 작업 수행
- **보상 트랜잭션 (C)**: 실패 시 이전 작업을 되돌리는 작업

> 보상은 진정한 롤백이 아니라 "반대 작업"이다. 예를 들어 주문 생성의 보상은 DELETE가 아니라 상태를 CANCELLED로 변경하는 것.

## 두 가지 구현 방식

### 1. Choreography (안무)

각 서비스가 이벤트를 발행하고 구독하며 자율적으로 반응.

```
주문 서비스 ──(OrderCreated)──→ 재고 서비스
                                    │
                             (StockReserved)
                                    ↓
주문 서비스 ←─(PaymentDone)─── 결제 서비스
```

실패 시에도 이벤트로 전파:

```
결제 실패 → PaymentFailed 발행 → 재고 서비스가 수신 → 재고 원복
```

**장점**: 서비스 간 느슨한 결합, 단순한 구조

**단점**: 전체 흐름 파악 어려움, 복잡해지면 스파게티

### 2. Orchestration (오케스트레이션)

중앙의 **Orchestrator**가 전체 흐름을 제어.

```
         ┌─────────────┐
         │ Orchestrator │
         └──────┬──────┘
                │
    ┌───────────┼───────────┐
    ↓           ↓           ↓
  주문        재고        결제
```

Orchestrator가 순서대로 각 서비스를 호출하고, 실패 시 역순으로 보상 트랜잭션을 호출.

**장점**: 흐름이 명확, 복잡한 로직 관리 용이

**단점**: Orchestrator가 단일 장애점이 될 수 있음

## 비교

| 항목        | Choreography          | Orchestration   |
| ----------- | --------------------- | --------------- |
| 흐름 파악   | 분산되어 어려움       | 한 곳에서 명확  |
| 결합도      | 느슨함                | 상대적으로 높음 |
| 적합한 경우 | 단순한 흐름 (3-4단계) | 복잡한 흐름     |
| 단일 장애점 | 없음                  | Orchestrator    |

## 실무 고려사항

**멱등성 필수**: 네트워크 재시도로 같은 요청이 여러 번 올 수 있으므로, 모든 작업은 멱등하게 설계해야 한다.

**Saga 상태 저장**: 장애 복구를 위해 현재 어느 단계인지 저장해둬야 한다.

**보상 실패 대비**: 보상 트랜잭션도 실패할 수 있다. Dead Letter Queue에 쌓아두고 수동 처리하거나 알림을 보내는 방식으로 대비.

**타임아웃**: 각 단계에 타임아웃을 걸어 무한 대기 방지.
