### 🔐 암호화/해싱 관련 알고리즘 및 기법 정리

---

## ✅ AES (Advanced Encryption Standard)

- **종류**: 대칭키 블록 암호화 알고리즘
- **동작 방식**:

  - 고정된 블록 크기(128비트)로 데이터를 암호화
  - 키 길이는 128, 192, 256비트 중 선택 가능
  - 대칭키이므로 **암호화와 복호화에 동일한 키 사용**

- **운용 모드**:

  - **CBC (Cipher Block Chaining)**: 이전 블록의 암호문을 다음 블록 암호화에 사용. IV 필요
  - **GCM (Galois/Counter Mode)**: 인증 기능 포함, IV는 반드시 매번 새로 생성해야 함

- **필요 요소**:

  - Key: 암호화 키 (정적 또는 파생)
  - IV (Initialization Vector): 첫 블록에 적용되는 랜덤값

---

## ✅ SHA-256 (Secure Hash Algorithm 256)

- **종류**: 단방향 해시 함수 (암호화 아님)
- **동작 방식**:

  - 어떤 길이의 입력이든 256비트(32바이트) 고정 길이 출력 생성
  - 복호화 불가능

- **용도**:

  - 무결성 검증
  - 데이터 식별자 생성
  - 암호화된 데이터 비교 (비밀번호 X)

- **보안 특성**:

  - 충돌 회피성, 역상 저항성 제공
  - 빠른 계산 속도로 인해 **단독 비밀번호 해싱용으로는 부적절**

---

## ✅ PBKDF2 (Password-Based Key Derivation Function 2)

- **종류**: 비밀번호 해싱을 위한 반복형 키 파생 함수
- **표준**: RFC 2898
- **구현체 (C#)**: `Rfc2898DeriveBytes` 클래스
- **동작 방식**:

  - 입력된 비밀번호와 무작위 Salt를 조합
  - 지정된 횟수만큼 반복적으로 해시 연산 수행 (ex: 100,000회)
  - 결과적으로 해시된 키(바이트 배열)를 생성

- **출력 형식 (관례)**:

  - 반복횟수.salt.base64-encoded-hash

- **보안 장점**:

  - 느린 연산을 강제하여 Brute-force 공격 방어
  - Salt 사용으로 동일한 비밀번호도 서로 다른 해시값 생성

---

## ✅ 고정 시간 비교 (Fixed-Time Equality)

- **목적**: 타이밍 공격 방지
- **문제점**:

  - 일반적인 `==` 비교는 첫 mismatch 지점에서 빠르게 종료되기 때문에 공격자가 비교 시간 분석 가능

- **해결**:

  - `FixedTimeEquals` (C#) 또는 유사 알고리즘 사용
  - 전체 바이트 길이 비교 시간 일정하게 유지

---

## 🔐 전체 흐름 요약

| 목적            | 기법/알고리즘               | 설명                          |
| --------------- | --------------------------- | ----------------------------- |
| 데이터 암복호화 | AES (CBC, GCM)              | 대칭키 방식, IV와 함께 사용됨 |
| 무결성 검증     | SHA-256                     | 빠른 단방향 해시, 복호화 불가 |
| 비밀번호 해싱   | PBKDF2 (Rfc2898DeriveBytes) | Salt + 반복 + 해시 조합       |
| 비교 보안 강화  | Fixed-Time Comparison       | 타이밍 분석 방지              |

---

각 기법은 목적과 특성에 맞춰 사용되어야 하며, 특히 **비밀번호 보관**에는 단순 해시보다 **PBKDF2 / bcrypt / Argon2**와 같은 키 파생 알고리즘을 사용하는 것이 필수적입니다.
