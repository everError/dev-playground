### 📌 Shebang (`#!`)

**Shebang**은 유닉스 계열 운영체제에서 **스크립트 파일의 첫 줄에 작성되는 특별한 문자 시퀀스**로, 해당 파일을 어떤 인터프리터로 실행할지 지정하는 역할을 합니다.

#### ✅ 문법:

```bash
#!/usr/bin/env python3
```

또는

```bash
#!/bin/bash
```

#### ✅ 의미:

- `#!` 뒤에 오는 경로는 **스크립트를 실행할 인터프리터의 절대 경로**입니다.
- 예: `#!/bin/bash` → 이 스크립트는 Bash 셸로 실행됨
- `#!/usr/bin/env python3` → PATH에 등록된 `python3`를 찾아 실행 (더 유연함)

#### ✅ 특징:

- 스크립트를 **직접 실행 가능하게 만듦** (예: `./script.sh`)
- 없는 경우, 실행 시 명시적으로 인터프리터를 지정해야 함 (`bash script.sh`)

---

### 📌 Idempotency (멱등성)

\*\*Idempotency(멱등성)\*\*은 **같은 요청을 여러 번 수행해도 결과가 변하지 않는 성질**을 의미합니다. RESTful API, 백엔드 시스템 설계, 결제 시스템 등에 매우 중요합니다.

#### ✅ 예시:

- `GET /users/1` → 유저 정보 조회 (몇 번 호출해도 같은 결과)
- `DELETE /users/1` → 이미 삭제된 유저에 대해 반복 호출해도 오류 없이 처리 가능해야 함
- `POST`는 기본적으로 멱등하지 않지만, 설계에 따라 멱등하게 만들 수 있음 (예: 클라이언트에서 idempotency key를 사용)

#### ✅ 왜 중요한가?

- **네트워크 재전송**으로 인한 중복 요청 처리
- **결제**, **회원가입**, **데이터 생성** 등에 대해 **중복 방지** 가능
- 안정적이고 예측 가능한 API 설계 가능

#### ✅ 적용 예시:

```http
POST /charge
Idempotency-Key: abc123
```

백엔드는 `abc123` 키로 이미 처리된 요청이 있다면, 동일한 응답을 반환하고 중복 처리를 방지함.

---

### 📌 Environment Variables (환경 변수)

\*\*환경 변수(Environment Variables)\*\*는 애플리케이션이 실행될 때 **외부에서 전달되는 설정 값**으로, 운영 환경에 따라 달라질 수 있는 정보를 관리합니다.

#### ✅ 사용 목적:

- 민감한 정보 숨기기 (예: DB 비밀번호, API 키)
- 환경별 설정 분리 (`dev`, `staging`, `prod` 등)
- Docker, CI/CD, 클라우드 배포 시 필수 요소

#### ✅ 예시:

```env
# .env 파일
DATABASE_URL=postgres://user:pass@localhost:5432/mydb
API_KEY=sk-xxx
```

Node.js에서 사용:

```js
const apiKey = process.env.API_KEY;
```

.NET에서 사용:

```csharp
var connStr = Environment.GetEnvironmentVariable("DATABASE_URL");
```

#### ✅ 관리 방법:

- `.env` 파일에 정의하고 `.gitignore`로 제외
- CI/CD에서는 플랫폼 설정 UI 또는 비밀 관리 서비스 사용 (ex: GitHub Actions Secrets, AWS SSM, Azure Key Vault)

---

### 📌 Webhook (웹훅)

\*\*웹훅(Webhook)\*\*은 특정 이벤트가 발생했을 때, 사전에 등록한 URL로 **HTTP 요청을 자동으로 전송하는 이벤트 기반 통신 방식**입니다.

#### ✅ 특징:

- 실시간 자동 알림 및 트리거 기능 제공
- REST API의 요청-응답과 달리 \*\*"푸시 기반"\*\*으로 작동
- 예: GitHub에서 Push 이벤트 발생 시 CI/CD 서버에 알림 전송

#### ✅ 활용 예시:

- GitHub → Jenkins/Tekton → CI 파이프라인 실행
- Stripe → 서버 → 결제 완료 처리
- Slack → 메시지 자동 전송

웹훅은 시스템 간 **느슨한 결합**과 **자동화**를 실현하는 핵심 기술입니다.

---

### Hydration

Hydration은 서버가 생성한 정적인 HTML 페이지(뼈대)에 JavaScript 코드를 연결하여, 동적인 대화형(Interactive) 웹 페이지로 '생명을 불어넣는' 과정을 의미합니다. 주로 Next.js, Nuxt.js와 같은 최신 프론트엔드 프레임워크에서 사용되는 핵심 개념입니다.

#### ✅ 동작 원리:

서버: 사용자가 페이지를 요청하면, 서버는 즉시 렌더링이 끝난 정적인 HTML 파일을 브라우저에 보냅니다.

브라우저 (초기 로드): 브라우저는 HTML을 받아 빠르게 화면에 표시합니다. 사용자는 콘텐츠를 바로 볼 수 있지만, 아직 버튼 클릭 등 상호작용은 불가능합니다.

브라우저 (Hydration): 백그라운드에서 다운로드된 JavaScript 번들이 실행되면서, 이미 존재하는 HTML 요소(DOM)에 이벤트 리스너(예: onClick) 등을 부착하고 상태(State)를 연결하여 상호작용이 가능한 완전한 웹 페이지로 만듭니다.

---

### Circuit Breaker

서킷 브레이커는 특정 서비스에 장애가 발생했을 때, 해당 서비스로 향하는 모든 요청을 일시적으로 차단하여 장애가 시스템 전체로 전파되는 것을 막는 디자인 패턴입니다. 이름 그대로, 전기 회로에서 과부하가 걸리면 끊어지는 '회로 차단기'와 같은 역할을 합니다.

#### ✅ 3가지 상태 (How it Works):

서킷 브레이커는 세 가지 상태를 가지며 자동으로 상태를 전환합니다.

Closed (닫힘): 평상시 상태로, 모든 요청이 정상적으로 전달됩니다. 하지만 실패하는 요청의 수를 계속해서 기록합니다.

Open (열림): 실패 횟수가 설정된 임계값을 초과하면, 서킷 브레이커가 '열립니다'. 이 상태에서는 요청을 실제로 보내지 않고 즉시 실패 응답을 반환합니다. 이를 통해 장애가 발생한 서비스가 복구될 시간을 벌어주고, 요청하는 쪽의 자원 낭비를 막습니다.

Half-Open (반-열림): Open 상태에서 일정 시간이 지나면, 서킷 브레이커는 '반-열림' 상태가 됩니다. 이 상태에서 제한된 수의 테스트 요청(Probe request)만 보냅니다.

이 요청이 성공하면, 서비스가 복구된 것으로 판단하고 다시 Closed 상태로 전환합니다.

이 요청이 실패하면, 서비스가 여전히 불안정하다고 판단하고 다시 Open 상태로 돌아갑니다.

#### ✅ 왜 중요한가?

장애 격리 및 전파 방지: 하나의 마이크로서비스 장애가 다른 서비스들로 연쇄적으로 퍼져나가는 '계단식 장애(Cascading Failures)'를 막아 시스템 전체의 붕괴를 방지합니다.

시스템 탄력성(Resilience) 확보: 장애가 발생한 서비스가 스스로 복구할 수 있도록 유도하며, 시스템이 장애 상황을 더 유연하게 대처할 수 있게 합니다.

빠른 실패(Fail Fast): 불필요한 응답 대기 시간을 없애고 즉시 실패를 반환함으로써 사용자 경험을 개선하고 시스템 자원을 보호합니다.

#### ✅ 적용 예시:

쇼핑몰의 '주문 서비스'가 '결제 서비스'를 호출할 때, 결제 서비스에 장애가 발생하면 서킷 브레이커가 열립니다. 이후 모든 주문 요청은 결제를 시도조차 하지 않고 즉시 "현재 결제 시스템 점검 중입니다."와 같은 안내를 보여줄 수 있습니다.
